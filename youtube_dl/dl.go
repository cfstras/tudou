package youtube_dl

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
	"syscall"
)

// The format of the info JSON file generated by youtube-dl
type Info struct {
	Extractor     string  `json:"extractor"`
	Playlist      *string `json:"playlist"`
	STitle        string  `json:"stitle"`
	Title         string  `json:"title"`
	VideoUrl      string  `json:"url"`
	Format        string  `json:"format"`
	PlaylistIndex *string `json:"playlist_index"`
	ThumbnailUrl  string  `json:"thumbnail"`
	Extension     string  `json:"ext"`
	FullTitle     string  `json:"fulltitle"`
	Id            int64   `json:"id"`
}

const TudouUrl = "http://tudou.com/programs/view/"

func Load(url string) (file *os.File, length int64, info Info, infoBytes []byte,
	err error) {

	file, err = ioutil.TempFile(".", "tudou-scraper-ytdl-")
	var tempFiles []string
	defer deleteTemps(&tempFiles)
	if file != nil {
		tempFiles = append(tempFiles, file.Name())
	}

	if err != nil {
		return
	}
	err = file.Close()
	if err != nil {
		return
	}
	err = os.Remove(file.Name())
	if err != nil {
		return
	}

	cmd := exec.Command("youtube-dl", "--verbose", "-o", file.Name(), "--write-info-json", url)

	pipe := func(r io.ReadCloser) {
		buf := bufio.NewReader(r)
		for {
			line, err := buf.ReadString('\n')
			line = strings.TrimRight(line, "\r\n")
			if err != nil && err == io.EOF {
				r.Close()
				return
			} else if err != nil {
				fmt.Println("Error reading from stderr:", err)
				return
			}
			fmt.Println(line)
		}
	}
	var stdout, stderr io.ReadCloser
	stdout, err = cmd.StdoutPipe()
	if err != nil {
		return
	}
	stderr, err = cmd.StderrPipe()
	if err != nil {
		return
	}
	go pipe(stdout)
	go pipe(stderr)

	infoFilename := file.Name() + ".info.json"
	tempFiles = append(tempFiles, infoFilename)
	tempFiles = append(tempFiles, file.Name()+".part")

	err = cmd.Start()
	if err != nil {
		return
	}

	err = cmd.Wait()
	if err != nil {
		return
	}

	infoBytes, err = ioutil.ReadFile(infoFilename)
	if err != nil {
		cmd.Process.Signal(syscall.SIGTERM)
		return
	}
	err = os.Remove(infoFilename)
	if err != nil {
		cmd.Process.Signal(syscall.SIGTERM)
		return
	}
	err = json.Unmarshal(infoBytes, &info)
	if err != nil {
		cmd.Process.Signal(syscall.SIGTERM)
		return
	}

	file, err = os.Open(file.Name())
	if err != nil {
		return
	}
	length, err = file.Seek(0, 2) // seek to end
	if err != nil {
		return
	}
	_, err = file.Seek(0, 0) // seek to start
	return
}

func deleteTemps(files *[]string) {
	for _, f := range *files {
		err := os.Remove(f)
		if err != nil {
			fmt.Println("Error deleting file "+f+":", err)
		}
	}
}
